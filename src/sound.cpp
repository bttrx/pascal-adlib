/*****************************************/
/*  Adlib Low Level Unit                 */
/*  Copyright (c) 1995, Carl Eric Codere */
/*  Montreal, Canada - September 1995    */
/*****************************************/
/*  See license.txt for usage of this source code  */
/* INFORMATION:                                                             */
/*   FIRST AND FOREMOST -> Jeffrey S. Lee for his documentation on the      */
/*      OPL2 Chipset found in the Adlib Sound Card.                         */
/*   UNDISCLOSED ADLIB CODE -> some BASIC Code written by Adlib, which      */
/*      actually contained some bugs.                                       */
/*   SBFMDRV Tracing to find out how to calculate the SemiTones and Note    */
/*      modifications.                                                      */
/*   and last but not least: The person who gave me the original idea of    */
/*      starting this project: Ezra Dreisbach with his C SCR FM Player.     */

/*  I did not succeed in creating the sounds exactly like the SBFMDRV (this */
/*  was my ultimate goal), but it is quite close, except in a few rare cases*/
/*  where the notes will sound awful.                                       */
/*  If you know how to create sound quality as good as the SBFMDRV let me   */
/*  know!!!                                                                 */

/* In percussive mode, the last 4 voices (SD TOM HH CYMB) are created      */
/* using melodic voices 7 & 8. A noise generator uses channels 7 & 8       */
/* frequency information for creating rhythm instruments. Best result      */
/* are obtained by setting TOM two octaves below middle C and SD 7         */
/* half-tones above TOM.                                                   */


// Do not forget that arrays in C++ are declared starting from zero and
// declaration are for the number of bytes used!!! 0..2 = 3 bytes used!

// LO AND HI PROCEDURES REPLACED BY >> 8 AND TYPECASTS.

#include <dos.h>
#include <conio.h>
#include <iostream.h>
#include <stdlib.h>
#include "\source\pascal\types.h"

// TEST WITH RANGE CHECKING
#define DEBUG

// TRUE/FALSE Boolean Values
// TYPECAST TO FIT IN A BYTE
#define TRUE   byte(1)
#define FALSE  byte(0)

// Routine Specific

//  { Do not forget that the voices start from voice ZERO ! }
#define  Modulator 0
#define  Carrier   1

/* Percussive Voice Numbers */
#define BassDrumVoice  6
#define SnareDrumVoice 7
#define TomTomVoice    8
#define CymbalVoice    9
#define HiHatVoice    10


/* CONSTANT DEFINITIONS */
 /*-----------------------------------------------------------------*/

 const unsigned char NoteTab[127] = {
        0x00,0x01,0x02,0x03,0x04,0x05,
        0x06,0x07,0x08,0x09,0x0a,0x0b,
        0x00,0x01,0x02,0x03,0x04,0x05,
        0x06,0x07,0x08,0x09,0x0a,0x0b,
        0x10,0x11,0x12,0x13,0x14,0x15,
        0x16,0x17,0x18,0x19,0x1a,0x1b,
        ' ','!','"',
        '#','$','%',
        '&', 0x00,'(',
        ')','*','+',
        '0','1','2',
        '3','4','5',
        '6','7','8',
        '9',':',';',
        '@','A','B',
        0x43,0x44,0x45,0x46,0x47,0x48,
        0x49,0x4a,0x4b,0x50,0x51,0x52,
        0x53,0x54,0x55,0x56,0x57,0x58,
        'Y','Z','[',
        '`','a','b',
        'c','d','e',
        'f','g','i',
        'j','k','p',
        'q','r','s',
        't','u',
        'v','w','x',
        'y','z','{',
        'p','q','r',
        's','t','u',
        'v','w','x',
        'y','z','{',
        '{','{','{',
        '{','{','{',
        '{','{'
        };

const unsigned char FreqTable[768] = {
        'W',
        0x01,0x58,0x01,0x58,0x01,0x59,
        0x01,0x59,0x01,0x5a,0x01,0x5b,
        0x01,0x5b,0x01,0x5c,0x01,0x5d,
        0x01,0x5d,0x01,0x5e,0x01,0x5e,
        0x01,0x5f,0x01,0x60,0x01,0x60,
        0x01,0x61,0x01,0x62,0x01,0x62,
        0x01,0x63,0x01,0x64,0x01,0x64,
        0x01,0x65,0x01,0x65,0x01,0x66,
        0x01,0x67,0x01,0x67,0x01,0x68,
        0x01,0x69,0x01,0x69,0x01,0x6a,
        0x01,0x6b,0x01,0x6b,0x01,0x6c,
        0x01,0x6d,0x01,0x6d,0x01,0x6e,
        0x01,0x6f,0x01,0x6f,0x01,0x70,
        0x01,0x71,0x01,0x71,0x01,0x72,
        0x01,0x73,0x01,0x73,0x01,0x74,
        0x01,0x75,0x01,0x75,0x01,0x76,
        0x01,0x77,0x01,0x77,0x01,0x78,
        0x01,0x79,0x01,0x79,0x01,0x7a,
        0x01,0x7b,0x01,0x7b,0x01,0x7c,
        0x01,0x7d,0x01,0x7d,0x01,0x7e,
        0x01,0x7f,0x01,0x80,0x01,0x80,
        0x01,0x81,0x01,0x82,0x01,0x82,
        0x01,0x83,0x01,0x84,0x01,0x84,
        0x01,0x85,0x01,0x86,0x01,0x87,
        0x01,0x87,0x01,0x88,0x01,0x89,
        0x01,0x89,0x01,0x8a,0x01,0x8b,
        0x01,0x8b,0x01,0x8c,0x01,0x8d,
        0x01,0x8e,0x01,0x8e,0x01,0x8f,
        0x01,0x90,0x01,0x91,0x01,0x91,
        0x01,0x92,0x01,0x93,0x01,0x93,
        0x01,0x94,0x01,0x95,0x01,0x96,
        0x01,0x96,0x01,0x97,0x01,0x98,
        0x01,0x99,0x01,0x99,0x01,0x9a,
        0x01,0x9b,0x01,0x9c,0x01,0x9c,
        0x01,0x9d,0x01,0x9e,0x01,0x9e,
        0x01,0x09f,0x01,0x0a0,0x01,0x0a1,
        0x01,0x0a1,0x01,0x0a2,0x01,0x0a3,
        0x01,0x0a4,0x01,0x0a5,0x01,0x0a5,
        0x01,0x0a6,0x01,0x0a7,0x01,0x0a8,
        0x01,0x0a8,0x01,0x0a9,0x01,0x0aa,
        0x01,0x0ab,0x01,0x0ab,0x01,0x0ac,
        0x01,0x0ad,0x01,0x0ae,0x01,0x0ae,
        0x01,0x0af,0x01,0x0b0,0x01,0x0b1,
        0x01,0x0b2,0x01,0x0b2,0x01,0x0b3,
        0x01,0x0b4,0x01,0x0b5,0x01,0x0b6,
        0x01,0x0b6,0x01,0x0b7,0x01,0x0b8,
        0x01,0x0b9,0x01,0x0ba,0x01,0x0ba,
        0x01,0x0bb,0x01,0x0bc,0x01,0x0bd,
        0x01,0x0be,0x01,0x0be,0x01,0x0bf,
        0x01,0x0c0,0x01,0x0c1,0x01,0x0c2,
        0x01,0x0c2,0x01,0x0c3,0x01,0x0c4,
        0x01,0x0c5,0x01,0x0c6,0x01,0x0c6,
        0x01,0x0c7,0x01,0x0c8,0x01,0x0c9,
        0x01,0x0ca,0x01,0x0cb,0x01,0x0cb,
        0x01,0x0cc,0x01,0x0cd,0x01,0x0ce,
        0x01,0x0cf,0x01,0x0d0,0x01,0x0d0,
        0x01,0x0d1,0x01,0x0d2,0x01,0x0d3,
        0x01,0x0d4,0x01,0x0d5,0x01,0x0d5,
        0x01,0x0d6,0x01,0x0d7,0x01,0x0d8,
        0x01,0x0d9,0x01,0x0da,0x01,0x0db,
        0x01,0x0db,0x01,0x0dc,0x01,0x0dd,
        0x01,0x0de,0x01,0x0df,0x01,0x0e0,
        0x01,0x0e1,0x01,0x0e1,0x01,0x0e2,
        0x01,0x0e3,0x01,0x0e4,0x01,0x0e5,
        0x01,0x0e6,0x01,0x0e7,0x01,0x0e8,
        0x01,0x0e8,0x01,0x0e9,0x01,0x0ea,
        0x01,0x0eb,0x01,0x0ec,0x01,0x0ed,
        0x01,0x0ee,0x01,0x0ef,0x01,0x0f0,
        0x01,0x0f0,0x01,0x0f1,0x01,0x0f2,
        0x01,0x0f3,0x01,0x0f4,0x01,0x0f5,
        0x01,0x0f6,0x01,0x0f7,0x01,0x0f8,
        0x01,0x0f9,0x01,0x0fa,0x01,0x0fa,
        0x01,0x0fb,0x01,0x0fc,0x01,0x0fd,
        0x01,0x0fe,0x01,0x0ff,0x01,0x00,
        0x02,0x01,0x02,0x02,0x02,0x03,
        0x02,0x04,0x02,0x05,0x02,0x06,
        0x02,0x06,0x02,0x07,0x02,0x08,
        0x02,0x09,0x02,0x0a,0x02,0x0b,
        0x02,0x0c,0x02,0x0d,0x02,0x0e,
        0x02,0x0f,0x02,0x10,0x02,0x11,
        0x02,0x12,0x02,0x13,0x02,0x14,
        0x02,0x15,0x02,0x16,0x02,0x17,
        0x02,0x18,0x02,0x19,0x02,0x1a,
        0x02,0x1a,0x02,0x1b,0x02,0x1c,
        0x02,0x1d,0x02,0x1e,0x02,0x1f,
        0x02,0x20,0x02,0x21,0x02,0x22,
        0x02,0x23,0x02,0x24,0x02,0x25,
        0x02,0x26,0x02,0x27,0x02,0x28,
        0x02,0x29,0x02,0x2a,0x02,0x2b,
        0x02,0x2c,0x02,0x2d,0x02,0x2e,
        0x02,0x2f,0x02,0x30,0x02,0x31,
        0x02,0x32,0x02,0x33,0x02,0x34,
        0x02,0x35,0x02,0x36,0x02,0x37,
        0x02,0x38,0x02,0x39,0x02,0x3b,
        0x02,0x3c,0x02,0x3d,0x02,0x3e,
        0x02,0x3f,0x02,0x40,0x02,0x41,
        0x02,0x42,0x02,0x43,0x02,0x44,
        0x02,0x45,0x02,0x46,0x02,0x47,
        0x02,0x48,0x02,0x49,0x02,0x4a,
        0x02,0x4b,0x02,0x4c,0x02,0x4d,
        0x02,0x4e,0x02,0x4f,0x02,0x51,
        0x02,0x52,0x02,0x53,0x02,0x54,
        0x02,0x55,0x02,0x56,0x02,0x57,
        0x02,0x58,0x02,0x59,0x02,0x5a,
        0x02,0x5b,0x02,0x5c,0x02,0x5e,
        0x02,0x5f,0x02,0x60,0x02,0x61,
        0x02,0x62,0x02,0x63,0x02,0x64,
        0x02,0x65,0x02,0x66,0x02,0x67,
        0x02,0x69,0x02,0x6a,0x02,0x6b,
        0x02,0x6c,0x02,0x6d,0x02,0x6e,
        0x02,0x6f,0x02,0x70,0x02,0x72,
        0x02,0x73,0x02,0x74,0x02,0x75,
        0x02,0x76,0x02,0x77,0x02,0x78,
        0x02,0x79,0x02,0x7b,0x02,0x7c,
        0x02,0x7d,0x02,0x7e,0x02,0x7f,
        0x02,0x80,0x02,0x82,0x02,0x83,
        0x02,0x84,0x02,0x85,0x02,0x86,
        0x02,0x87,0x02,0x89,0x02,0x8a,
        0x02,0x8b,0x02,0x8c,0x02,0x8d,
        0x02,0x8e,0x02,0x90,0x02,0x91,
        0x02,0x92,0x02,0x93,0x02,0x94,
        0x02,0x96,0x02,0x97,0x02,0x98,
        0x02,0x99,0x02,0x9a,0x02,0x9c,
        0x02,0x9d,0x02,0x9e,0x02,0x09f,
        0x02,0x0a0,0x02,0x0a2,0x02,0x0a3,
        0x02,0x0a4,0x02,0x0a5,0x02,0x0a6,
        0x02,0x0a8,0x02,0x0a9,0x02,0x0aa,
        0x02,0x0ab,0x02,0x0ad,0x02
        };

// (* Offset of modulator for each voice *)
const unsigned char TableModulator[14] = {
        0x00,0x01,0x02,0x08,0x09,0x0a,
        0x10,0x11,0x12,0x01,0x11,0x4f,
        0x00,0x0f1             };

// (* Offset of operator for percussive mode     *)
// (* Offset memory boundary cross in ASM Source *)
// (* Error is quite possible                    *)
const TablePModulator[11] = {
         0xf2,0x53,0x74,0x00,0x00,0x08,
         0x10,0x14,0x12,0x15,0x11 };

//(* Offset of Modulator in each voice *)
const unsigned char SlotMVoice[9][2] = {

        {0x00, 0x03},
        {0x01, 0x04},
        {0x02, 0x05},
        {0x08, 0x0B},
        {0x09, 0x0C},
        {0x0a, 0x0D},
        {0x10, 0x13},
        {0x11, 0x14},
        {0x12, 0x15}
         };

//  { Percussion Rhythm Enable bits }
const unsigned char PercBits[5] =
//{ FIRST TABLE TAKEN FROM SBFMDRV.ASM  }
//{               ($08,$10,$14,$12,$15) }
//{ 2ND TABLE TAKEN FROM ADLIB.C        }
//      { VOICES:   6   7   8   9  10 }
      {0x10,0x08,0x04,0x02,0x01};
//         ; {Percussion Mode Enable Voice bits.}

const unsigned char PercussiveOffset[11] = {
           0x11,0x10,0x08,0x04,0x02,0x01,
           0x06,0x07,0x08,0x08,0x07};
//         ; { Offset voice when in percussive voice. }


// Forwards.
void SndOutput(int reg, byte value);
boolean BoardInstalled(void);


// Implementation.



 // INTERNAL ROUTINE RANGE CHECKING
#ifdef DEBUG
 template <class T>
 void check(T lower, T upper, T val)
 {
  if ((val < lower) || (val > upper))
  {
   cout << "ERROR OUT OF BOUNDS" << endl;
   abort();
  }
 };
#endif


boolean BoardInstalled()
// Returns TRUE if an adlib card was detected
// otherwise returns false.
{
  byte Stat1;
  byte Stat2;
 SndOutput(0x04,0x60);      // Reset both timers       *)
 SndOutput(0x04,0x80);      // Enable Timer interrupts *)
 Stat1 = inp(0x388);       // Read Status Register    *)
 SndOutput(0x02,0xFF);
 SndOutput(0x04,0x21);      // Start Timer 21h         *)
 delay(100);               // Wait 80 ms              *)
 Stat2 = inp(0x388);       // Read Status Register    *)
 SndOutput(0x04,0x60);      // Reset both timers       *)
 SndOutput(0x04,0x80);      // Enable timer interrupts *)
 Stat1 = Stat1 & 0xE0;
 Stat2 = Stat2 & 0xE0;
 if ((Stat1 == 0x00) && (Stat2 == 0xC0))
    return TRUE;
 else
    return FALSE;
}




void SndOutput(byte reg, byte value)
// (****************************************************************)
// (* * PROCEDURE SndOutPut(reg: Integer; Value: Byte);          * *)
// (* *  Writes to a specified Adlib register.                   * *)
// (* *  reg -> register number to write to                      * *)
// (* *  value -> value to write to register                     * *)
// (****************************************************************)
 {
 int i;
 outp(0x388, reg);
 for ( i = 0; i < 35; i = i+1);
 outp(0x389, value);
 }



 // Object Declarations
class TAdlib:Object {
 public:
//  { This determines if botyh operators produce sound directly      }
//  { i so, then modyfing volume must be done by with both operators }
//  { TRUE = Both Modulator and Carrier must be changed to change    }
//  { the volume.                                                    }
  boolean Algorithm[11];
  boolean Percussive;          //   (* Percussion Mode parameter *)
  int Voices;                  //   (* maximum number of available voices *)
  byte PlayingNote[11];
  boolean Playing[11];        //    (* TRUE if a note is playing          *)
  byte Volume[16];
  byte ModulatorScalingLevel[11];
  byte CarrierScalingLevel[11];
  word Output[11];
  int SemiToneCurrent[11];
  byte BdRegister;             // Current value of BDRegister
  void Init(void);                // Init Constructor. constructor
  void Done(void);               // Destructor Done
  virtual void CardNotInstalled(void);
  void NoteOff(unsigned char Voice, unsigned char Note);
  void NoteOn(unsigned char Voice, unsigned char Note);
  void SetVolume(unsigned char Voice, unsigned char AVolume);
  void SemiToneup(unsigned char Voice, unsigned char Value);
  void SemiToneDown(unsigned char Voice, unsigned char Value);
  word CalcNote(byte Voice,byte Note);

// (* Selects either Melodic or Percussive mode *)
// (* TRUE = Percussive Mode                    *)
  void SetPercussive(boolean Mode);
 };



void TAdlib::Init()
{
  byte i;
  // (* If an Adlib compatible sound card is NOT installed *)
   if (!BoardInstalled)
     CardNotInstalled();
 //   (* Reset the Sound Card *)
   for (i = 0x01; i <= 0xF5; i = i + 1)
   {
     SndOutput(i, 0x00);
   }

   SndOutput(0x01, 0x20);
   SndOutput(0x08, 0x40);
 //  { Also sets the correct instruments }
   SetPercussive(FALSE);
};





void TAdlib::Done()
{
  byte i;
  //  (* Reset\Silence the Sound Card *)
  // { This could be replaced by a gradual scale down }
   for (i = 0x01; i <= 0xF5; i = i + 1)
   {
      SndOutput(i, 0x00);
   }
};


void TAdlib::SetPercussive(boolean Mode)
{
 // This is a melodic mode
 #ifdef DEBUG
 // Range checking code
  check(FALSE, TRUE, Mode);
 #endif
 // End range checking code
 if (!Mode)
 {
   Voices = 0x08;
   BdRegister = 0xC0;
   SndOutput(0xBD, BdRegister);
 } else
 {
   Voices = 0x06;
   BdRegister = 0xE0;
   SndOutput(0xBD, BdRegister);
 }
};


void TAdlib::CardNotInstalled()
{
 cout << "ADLIB CARD NOT FOUND" << endl;
 abort;
};


void TAdlib::NoteOff(unsigned char Voice, unsigned char Note)
{
 if (!Playing[Voice]) return;
// { Melodic Voice }
 if (((Percussive) && (Voice < BassDrumVoice)) || (!Percussive))
 {
   Playing[Voice] = FALSE;
//   { We just need to rewrite to $B0 register }
   SndOutput(0xB0 + Voice, (byte)(Output[Voice] >> 8));
 }
 else
 {
// { Percussive Voice }
   BdRegister = BdRegister & (~PercBits[Voice - 6]);
   Playing[Voice] = FALSE;
//   { Disable thee key-on for that percussive voice }
   SndOutput(0xBD, BdRegister);
 }
};



void TAdlib::NoteOn(unsigned char Voice, unsigned char Note)
/*******************************************************************
   NOTEON: Plays a note on the Adlib Sound Card.
*******************************************************************/
{
// { Do a note off if note is already playing }
 if (Playing[Voice])
 {
  SndOutput(0xA0 + Voice, (byte)(Output[Voice]));
  SndOutput(0xB0 + Voice, (byte)(Output[Voice]) >> 8);
 }

 if (Note > 107)
  Note = 107;
 if (Note < 12)
  Note = 12;
 PlayingNote[Voice] = Note;

// { Melodic voice }
 if (((Percussive) || (Voice < BassDrumVoice)) || (!Percussive))
 {
   Output[Voice] = CalcNote(Voice, Note);
   SndOutput(0xA0 + Voice, (byte)(Output[Voice]));
//   { Enable key on by adding bitwise bit 5 }
   SndOutput(0xB0 + Voice, (byte)((Output[Voice]) >> 8) | 0x20);
   Playing[Voice] = TRUE;
 }
 else
 {
// { Percussive Voice }
   BdRegister = BdRegister | PercBits[Voice-6];
   Output[Voice] = CalcNote(Voice, Note);
   Playing[Voice] = TRUE;
   SndOutput(0xA0 + PercussiveOffset[Voice], (byte)(Output[Voice]));
   SndOutput(0xB0 + PercussiveOffset[Voice], (byte)(Output[Voice]) >> 8);

//   { Enable Key on in Rhythm Node }
   SndOutput(0xBD, BdRegister);
  }
 };


